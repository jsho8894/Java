package com.bit.mySelf01;

import java.util.Scanner;

/*
 * 2세대 언어에선 우리가 프로그램을 기능의 집합이라고생각했고
 * 따라서 기능을 만들어서 재사용하여 코드를 쓰는 양을 줄였습니다
 * 
 * 하지만3세대 프로그래밍부터는
 * 프로그램을 작은 프로그램들의 집합으로 보았고 
 * 더 코드를 사용하여 우리가 덜귀찮게 코딩할 수 있게되었다
 * 성적 관리프로그램같은경우
 * 2세대 언어에선
 * 구조체라고 하는 변수들의 모임을 만들어 그자체를 하나의 변수롤 사용했다
 * 예를 들어 
 * String name ,int  age int korean , int math ,int english를 안에 가지고 있는 하나의
 * student 라는 구조체를 만들어서 우리가 데이터를 저장했고 그리고
 * 함수라는 것을 만들어 그 프로그램의 기능을 지정했습니다
 * 즉 프로그램을 데이터를 담당하는 부분과 기능 부분을 분리를 해서 만들었던 것입니다.
 * 
 * 즉 우리들은 데이터의 생김새르 재사용하던 아니면 함수를 재사용하던 둘 중 하나를 재사용하거나
 * 모두 재사용 하려면 따로따로 모두 불러와야합니다.
 * 
 * 하지만 3세대 언어에서는 데이터의 형태와 그리고 기능을 하나의 클래스로 합쳐 통쨰로
 * 가져다 쓰자 요렇게 인식이 바뀌게 된것입니다.
 * 
 * 예를 들어 Student 라는 클래스의 경우 학생의 정보를 담당할 필드들과 메소드를 만들어 우리가
 * 필요할 때마다 Student클래스의 변수 즉 Student 객체를 만들어서 사용하면 됩니다.
 * 
 * 우리가 만들 Student 클래스를 활용하는 다른클래스에서 
 * 2개의 객체 학생 A와 B를 만들었을때
 * 학생의 A와 B의 기능적인 차이는 없습니다.
 * 
 * 그럼 2개의 객체의 차이는 필드에 값이 저장되어 있는 값이 틀려짐에서 나오게 됩니다.
 * 
 * 이 개념이 더 나아가게 되면 
 * POJO라는 개념에 도달하게 됩니다
 *Plain Ole Java Object(구식의 옛날 자바 객체)
 * 최대한 공통분모만 모아 보자 >공통분모가 없으면 다른클래스
 * SOLID
S(두문자)	SRP(약어)
단일 책임 원칙 (Single responsibility principle)
한 클래스는 하나의 책임만 가져야 합니다 
만약 데이터를 담당해야한다면?
어떤필드가 있고 그 필드와 메소드를을 정의해주게됩니다
만야UI를 담당해야한다면?
그러면 UI와 관련됨 메소드와 필드를 넣어주면된다
만약 데이터를 담당하는 클래스에 값을 받아오거나 UI에서 값을 받아 클래스를 객체를
만들어주는 클래스가 있다면 
그것만 있으면 됩니다

즉 엄격한 클래스 분리를 통해서 우리가 필요한 클래스만 정확하게 재사용할수 있게됩니다.
만약 어떤 클래스가 다른 클래스가 꼭 필요해진다면.
ex) 위에서 언급한 데이터를 담당하는 클래스르 사용하는 클래스(주로 컨트롤러)는
그 데이터를 담당하는 클래스가 없다면 아무것도 하지 못합니다.
즉 2개의 클래스는 컨트롤러라는 클래스가 데이터를 담당하는 클래스에 의존적인 관계가 됩니다.
그렇다면 데이터를 담당하는 클래스가 변경이 되면 컨트롤러도 변경이 되어야합니다.

근데 이 변경을 피하려면 어떨헤 해야할까?
ex)컨트롤러는 데이터 담당 클래스가 변경되더라도 코드상의 변경이 없거나 최대한 적게됩니다.
그렇다면 컨트롤러는 그 외부 클래스를 자기가 값을 넣거나 빼지 않고 
그냥 만들어져 있는걸 그대로 받아다가 쓰면 되지 않을까 생각할수 있습니다
이렇게 외부 클래스에 의존적일때 해당 클래스가 그 외부클래스를 직접 만들어서 쓰지 않고 
외부에서 받아다가 쓰는걸 의존성 주입(Dependency Injection)이라고 합니다.

이 의존성 주입의 경우 예전에는 우리가 코드로 직접 구현을 했지만 스프링을 배우면 대신 해줍니다








O(두문자)	OCP(약어) (아직 신경쓰지는 마세요)
개방-폐쇄 원칙 (Open/closed principle)
“소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.”

L(두문자)	LSP(약어) (아직 신경쓰지는 마세요)
리스코프 치환 원칙 (Liskov substitution principle)
“프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.” 계약에 의한 설계를 참고하라.

I(두문자)	ISP(약어) (아직 신경쓰지는 마세요)
인터페이스 분리 원칙 (Interface segregation principle)
“특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”[4]

D(두문자)	DIP(약어) (아직 신경쓰지는 마세요)
의존관계 역전 원칙 (Dependency inversion principle)
프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”[4] 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
 * 
 * 
 * */
public class StudentVer1 {//클래스명에 커서를 두고art+shift+r 변수와 클래스명을 바꿀때 사용합니다. 파일이름도 같이 바꾸어 줍니다.
	//2세대 코딩에서 코딩했을떄
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		System.out.println("학생의 이름을 입력하세요:");
		String name = scanner.nextLine();
		System.out.println("학생의 국어점수를 입력하세요");
		int korean = scanner.nextInt();
		System.out.println("학생의 영어점수를 입력하세요");
		int english = scanner.nextInt();
		System.out.println("학생의 수학점수를 입력하세요");
		int math = scanner.nextInt();
		int sum = korean + english + math;
		double average = sum/3.0;
		System.out.printf("학생의 이름 %s\t국어 점수 %d\t 영어점수: %d\t 수학점수: %d\t 총점: %d\t평균: %.2f",
				name,korean,english, math,sum,average);
		scanner.close();	
	}
}
